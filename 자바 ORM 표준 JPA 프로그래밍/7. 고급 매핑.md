## 1. 상속 관계 매핑

> 관계형 데이터베이스에는 객체지향 언어에서 다루는 상속이라는 개념이 없다.

ORM에서 상속 관계 매핑은 객체의 상속 구조와 데이터베이스의 슈퍼타입 서브타입 관계를 매핑하는 것이다. 

![image](https://images.velog.io/images/tigger/post/47914a6a-5850-4c3f-b775-866c5c7f122e/image.png)

지금부터 위 그림의 객체 상속 모델을 3가지 방법으로 매핑해보자.

### 조인 전략

**Table**

![image](https://images.velog.io/images/tigger/post/34635ac7-cc78-46a9-ae28-fd39398a1eae/image.png)

객체는 타입으로 구분할 수 있지만, 테이블은 타입의 개념이 없기 때문에 구분하는 컬럼(DTYPE)을 추가해야 한다.

**Entity**

```java
@Entity
@Inheritance(strategy = InheritanceType.JOINED) // 상속 매핑은 부모 클래스에 사용, 매핑 전략 JOINED 사용
@DiscriminatorColumn(name = "DTYPE") // 구분 컬럼 지정, 저장된 자식 테이블 구분, 기본값이 DTYPE
public abstract class Item {
    
    @Id
    @GeneratedValue
    @Column(name = "ITEM_ID")
    private Long id;
    
    private String name;
    private int price;
    
    // ...
}

@Entity
@DiscriminatorValue("A") // 엔티티를 저장할 때 구분 컬럼에 입력할 값 지정, DTYPE에 "A" 저장
public class Album extends Item {
    
    private String artist;
    
    // ...
}

@Entity
@DiscriminatorValue("M")
public class Movie extends Item {
    
    private String director;
    private String actor;
    
    // ...
}

@Entity
@DiscriminatorValue("B")
@PrimaryKeyJoinColumn(name = "BOOK_ID") // 부모 테이블의 ID 컬럼명을 변경하고 싶으면 사용
public class Book extends Item {
    
    private String acthor;
    private String isbn;
    
    // ...
}
```

**장점**

- 테이블 정규화
- 외래 키 참조 무결성 제약조건 활용
- 저장공간 효율적 사용

**단점**

- 조회 시 조인이 많아 성능 저하 우려
- 조회 쿼리 복잡
- 데이터 등록할 INSERT SQL 두 번 실행

### 단일 테이블 전략

**Table**

![image](https://images.velog.io/images/tigger/post/9c06ad1d-e5a0-4613-bb8a-7ec2d61dfede/image.png)

말 그대로 테이블 하나만 사용한다. 주의점은 자식 엔티티가 매핑한 컬럼은 모두 null을 허용해야 한다는 점이다. (ALBUM 테이블은 ARTIST 컬럼만 사용하기 때문에 나머지 컬럼은 null이 입력된다.)

**Entity**

```java
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE) // 매핑 전략 SINGLE_TABLE 사용
@DiscriminatorColumn(name = "DTYPE") // 꼭 사용
public abstract class Item {
    
    @Id
    @GeneratedValue
    @Column(name = "ITEM_ID")
    private Long id;
    
    private String name;
    private int price;
    
    // ...
}

@Entity
@DiscriminatorValue("A")
public class Album extends Item {

    // ...
}

@Entity
@DiscriminatorValue("M")
public class Movie extends Item {
    
    // ...
}

@Entity
@DiscriminatorValue("B")
public class Book extends Item {

    // ...
}
```

**장점**

- 조인이 필요 없으므로 일반적으로 조회 성능이 좋음
- 조회 쿼리 단순

**단점**

- 자식 엔티티가 매핑한 컴럼은 모두 null 허용
- 테이블이 커질 수 있음 → 조회 성능이 오히려 느려질 수 있음

### 구현 클래스마다 테이블 전략

**Table**

![image](https://images.velog.io/images/tigger/post/765a9fee-e908-4dc9-ba85-249e7a0969a8/image.png)

자식 테이블에 필요한 컬럼을 모두 넣는다.

**Entity**

```java
@Entity
@Inheritance(strategy = InheritanceType.TABLE_PRE_CLASS) // 매핑 전략 TABLE_PRE_CLASS 사용
public abstract class Item {
    
    @Id
    @GeneratedValue
    @Column(name = "ITEM_ID")
    private Long id;
    
    private String name;
    private int price;
    
    // ...
}

@Entity
public class Album extends Item {

    // ...
}

@Entity
public class Movie extends Item {
    
    // ...
}

@Entity
public class Book extends Item {

    // ...
}
```

구분 컬럼을 사용하지 않는다. 일반적으로 추천하지 않는 전략이라고 한다.

**장점**

- 서브 타입을 구분해서 처리할 때 효과적
- not null 제약조건 사용 가능

**단점**

- 여러 자식 테이블을 함께 조회할 때 성능이 느림
- 자식 테이블을 통합해서 쿼리하기 힘듦

## @MappedSuperclass